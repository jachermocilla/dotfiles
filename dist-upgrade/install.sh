#!/bin/bash
# =============================================================================
# install_packages.sh
# Installs packages from an exported package list (generated by export_packages.sh)
# Uses the package versions available in the CURRENT distribution (not pinned versions)
# =============================================================================

set -euo pipefail

# --- Config ------------------------------------------------------------------
INPUT_FILE="${1:-}"
LOG_FILE="install_packages_$(date +%Y%m%d_%H%M%S).log"
SKIPPED=()
FAILED=()
INSTALLED=()

# --- Helpers -----------------------------------------------------------------
log()     { echo "$1" | tee -a "$LOG_FILE"; }
success() { echo -e "\e[32m[OK]\e[0m $1"     | tee -a "$LOG_FILE"; }
warn()    { echo -e "\e[33m[SKIP]\e[0m $1"   | tee -a "$LOG_FILE"; }
error()   { echo -e "\e[31m[FAIL]\e[0m $1"   | tee -a "$LOG_FILE"; }

# --- Checks ------------------------------------------------------------------
if [[ -z "$INPUT_FILE" ]]; then
  echo "Usage: $0 <package-list-file>"
  echo "  Example: $0 packages_jammy_20260218.txt"
  exit 1
fi

if [[ ! -f "$INPUT_FILE" ]]; then
  echo "Error: File '$INPUT_FILE' not found."
  exit 1
fi

if [[ "$EUID" -ne 0 ]]; then
  echo "This script must be run as root. Try: sudo $0 $INPUT_FILE"
  exit 1
fi

# --- Start -------------------------------------------------------------------
DISTRO=$(lsb_release -cs)
log "======================================================"
log " Install Packages Script"
log " Date     : $(date)"
log " Distro   : $(lsb_release -ds) ($DISTRO)"
log " Input    : $INPUT_FILE"
log " Log file : $LOG_FILE"
log "======================================================"
log ""

log "Updating package index..."
apt-get update -qq | tee -a "$LOG_FILE"
log ""

# Read packages (skip blank lines and comments)
mapfile -t PACKAGES < <(grep -v '^\s*#' "$INPUT_FILE" | grep -v '^\s*$' | awk '{print $1}')
TOTAL=${#PACKAGES[@]}
log "Packages to process: $TOTAL"
log ""

# --- Install loop ------------------------------------------------------------
COUNT=0
for PKG in "${PACKAGES[@]}"; do
  COUNT=$((COUNT + 1))
  PREFIX="[$COUNT/$TOTAL] $PKG"

  # Strip any version suffix the user may have left in (e.g. pkg=1.2.3)
  PKG_NAME="${PKG%%=*}"

  # Check if package is available in the current distro repos
  if ! apt-cache show "$PKG_NAME" &>/dev/null; then
    warn "$PREFIX — not found in repos for '$DISTRO', skipping."
    SKIPPED+=("$PKG_NAME")
    continue
  fi

  # Check if already installed (at any version)
  if dpkg-query -W -f='${Status}' "$PKG_NAME" 2>/dev/null | grep -q "install ok installed"; then
    success "$PREFIX — already installed."
    INSTALLED+=("$PKG_NAME (already present)")
    continue
  fi

  # Install using the distro's current available version (no version pinning)
  log "Installing $PREFIX ..."
  if apt-get install -y --no-install-recommends "$PKG_NAME" >> "$LOG_FILE" 2>&1; then
    INSTALLED_VER=$(dpkg-query -W -f='${Version}' "$PKG_NAME" 2>/dev/null || echo "unknown")
    success "$PREFIX — installed (version: $INSTALLED_VER)"
    INSTALLED+=("$PKG_NAME=$INSTALLED_VER")
  else
    error "$PREFIX — installation failed."
    FAILED+=("$PKG_NAME")
  fi
done

# --- Summary -----------------------------------------------------------------
log ""
log "======================================================"
log " Summary"
log "======================================================"
log " Total    : $TOTAL"
log " Success  : ${#INSTALLED[@]}"
log " Skipped  : ${#SKIPPED[@]}"
log " Failed   : ${#FAILED[@]}"

if [[ ${#SKIPPED[@]} -gt 0 ]]; then
  log ""
  log "Skipped packages (not available in $DISTRO):"
  for p in "${SKIPPED[@]}"; do log "  - $p"; done
fi

if [[ ${#FAILED[@]} -gt 0 ]]; then
  log ""
  log "Failed packages (check $LOG_FILE for details):"
  for p in "${FAILED[@]}"; do log "  - $p"; done
fi

log ""
log "Full log saved to: $LOG_FILE"
log "======================================================"

# Exit with error code if any package failed
[[ ${#FAILED[@]} -eq 0 ]] && exit 0 || exit 1
